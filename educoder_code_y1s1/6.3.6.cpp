// 任务描述
// 本关任务：某单位在某个湖里举行潜水比赛，这是一个团体项目，每一支队伍由n人组成，要求所有队员从A岸潜水到B岸。
// 在潜水过程中必须用氧气瓶，但每支队伍只有一个氧气瓶。
// 最多两个人同时使用一个氧气瓶，但此时两人必须同步前进，因此到达终点的时间等于较慢的一人单独从A到B的时间。
// 大家都很Nice，随便两个人都愿意共用一个氧气瓶一起游泳。请安排一种策略，让最后一名队员尽早到达终点。

// 编程要求
// 根据提示，在右侧编辑器补充代码，首先输入队伍人数n（n <= 1000），接着是n个队员单独游到终点所用的时间。
// 要求输出所有队员最早到达终点的时间。

// 相关知识
// 可以通过sort函数对数组进行排序，需要用到的头文件已经给出。例如

// int a[] = {5,4,3,2,1};
// sort(a,a+5);
// // 输出a将得到1,2,3,4,5
// 提示：
// 首先将n个队员游到终点耗时长短按递增排序，得到
// P(1)P(2)…P(n)
// 我们把A岸耗时最长的两个人P(n)，P(n−1)游到B岸看成一个步骤。为了达到耗时最短，需要在如下两种方案中选择。

// 方案1：安排耗时最短的两个人P(1)，P(2)先游到B岸，然后P(1)游回A岸，接着安排耗时最长的两个人P(n)，P(n-1)游到B岸，
// 再安排P(2)游回A岸，总耗时t1=2∗P(2)+P(1)+P(n)

// 方案2：安排耗时最短和最长的P(1)，P(n)先游到B岸，P(n)留在B岸，P(1)回A岸。
// 然后P(1)，P(n-1)游到B岸，再安排P(1)游回A岸。总时间为t2=2∗P(1)+P(n)+P(n-1)

// 如果t1<t2，就选择方案1，否则选择方案2。重复上述策略，直到所有人到达B。算法实现时还需要考虑人数奇偶。
// 如果是奇数，最后在A岸剩下人为P(1)，P(2)，P(3)，3人到达B岸耗时P(1)+P(2)+P(3)，
// 如果是偶数，最后剩下两人为P(1)，P(2),耗时P(2).

// 测试说明
// 平台会对你编写的代码进行测试：

// 测试输入：3 1 3 4
// 预期输出：
// 8
#include<iostream>
#include<algorithm>
using namespace std;

//你的代码
int swim(int* p, int n){
    int i=n-1;
    int result = 0;
    while(i > 2){
        result += min(2**p+*(p+i)+*(p+i-1),2**(p+1)+*p+*(p+i));
        i-=2;
    }
    if(i==2){
        result += *p+*(p+1)+*(p+2);
    }
    else if(i==1){
        result += *(p+1);
    }
    else{
        return -1;
    }
    return result;
}

int main()
{
   	int n,p[1000],i;
    cin>>n;
    for(i=0;i<n;i++) cin>>p[i];
    sort(p,p+n);
    cout<<swim(p,n);
    return 0;
}