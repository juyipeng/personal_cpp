// 任务描述
// 本关任务：观察下面的数字金字塔，寻找一个算法查找从最高点到底部任意处结束的路径，使路径经过的数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。
//         7
//        3 8
//       8 1 1
//      2 7 4 4
//     4 5 2 6 5
// 在上面的例子中，从 7 到 3 到 8 到 7 到 5 的路径产生了最大的数字和。

// 编程要求
// 根据提示，在右侧编辑器补充代码，编写一个程序，首先输入数字金字塔层次数R（1≤R≤10），接着输入这个数字金字塔每行包含的整数（所有整数大于等于0且小于100），输出计算出来的最大的和。

// 提示：设置一个两维数组 f，f[i，j] 表示从最高点（最高点为第 1 层）到达第 i 层第 j 个位置时经过路径数字的最大和，则 f[i+1，j]+=Max{ f[i，j-1]，f[i，j]}（1≤i≤r-1，1≤j≤i）。请注意边界值的处理，f[i，0]=0。

// 测试说明
// 平台会对你编写的代码进行测试：

// 测试输入：5 7 3 8 8 1 1 2 7 4 4 4 5 2 6 5
// 预期输出：
// 30
// 输入说明：与任务描述中的图形对应

#include <iostream>

using namespace std;

int main()
{
    int f[11][12] = {0};
    int r = 0;
    cin>> r;
    for (int i = 1; i <= r; i++)
    {
        for (int j = 1; j <= i; j++)
        {
            cin>> f[i][j];
        }
    }
    for (int i = 2; i <= r; i++)
    {
        for (int j = 1; j <= i; j++)
        {
            f[i][j] += (f[i-1][j]>f[i-1][j-1]?f[i-1][j]:f[i-1][j-1]);
        }
    }
    int result = 0;
    for (int i = 1; i <= r; i++)
    {
        if (f[r][i] > result)
        {result = f[r][i];}
    }
    cout<< result;
}